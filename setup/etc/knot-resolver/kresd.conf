-- Knot DNS Resolver configuration in -*- lua -*-
local min_ttl = 300
local max_ttl = 86400
local negative_ttl = 10800
local systemd_instance = os.getenv('SYSTEMD_INSTANCE')
local dns_mode = os.getenv('ANTIZAPRET_DNS') or '1'
local alt_ip = os.getenv('ALTERNATIVE_IP') or 'n'

local base_ip = (alt_ip == 'y') and '172' or '10'
local listen_ip = (systemd_instance == '1') and (base_ip .. '.77.77.77') or '127.0.0.1'
local listen_port = 53

-- DNS Upstreams mapping
local upstreams = {
    -- Default (Cloudflare+Quad9+MSK-IX+SkyDNS)
    ['1'] = {
        main = {'62.76.76.62', '62.76.62.76', '193.58.251.251'},
        proxy = {'1.1.1.1', '1.0.0.1', '9.9.9.10', '149.112.112.10', '2606:4700:4700::1111', '2606:4700:4700::1001', '2620:fe::fe', '2620:fe::9'}
    },
    -- SkyDNS
    ['2'] = {
        main = {'127.0.0.1'},
        proxy = {'193.58.251.251'}
    },
    -- Cloudflare+Quad9
    ['3'] = {
        main = {'1.1.1.1', '1.0.0.1', '9.9.9.10', '149.112.112.10'},
        proxy = {'1.1.1.1', '1.0.0.1', '9.9.9.10', '149.112.112.10'}
    },
    -- Comss
    ['4'] = {
        main = {'83.220.169.155', '212.109.195.93', '195.133.25.16'},
        proxy = {'83.220.169.155', '212.109.195.93', '195.133.25.16'}
    },
    -- XBox
    ['5'] = {
        main = {'176.99.11.77', '80.78.247.254', '31.192.108.180'},
        proxy = {'176.99.11.77', '80.78.247.254', '31.192.108.180'}
    },
    -- Malw
    ['6'] = {
        main = {'84.21.189.133', '193.23.209.189'},
        proxy = {'84.21.189.133', '193.23.209.189'}
    }
}

local current_upstreams = upstreams[dns_mode] or upstreams['1']
local alternative_zones = policy.todnames({
    'bbs', 'chan', 'cyb', 'dyn', 'epic', 'geek', 'gopher', 'indy', 'libre', 'neo', 'null', 'o', 'oss', 'oz', 'parody', 'pirate', 'opennic.glue',
    'bazar', 'coin', 'emc', 'lib', 'fur', 'ku', 'te', 'ti', 'uu', 'ko', 'rm'
})

-- Networking
net.listen(listen_ip, listen_port, {kind = 'dns', freebind = true})
if systemd_instance == '1' then
    net.listen('::1', 53, {kind = 'dns', freebind = true})
else
    net.listen('::2', 53, {kind = 'dns', freebind = true})
end

user('knot-resolver', 'knot-resolver')
cache.open(100 * MB, 'lmdb:///var/cache/knot-resolver' .. (systemd_instance == '2' and '2' or ''))

modules = {
    'view',
    'predict',
    renumber = dofile('/etc/knot-resolver/renumber' .. (systemd_instance == '2' and '2' or '') .. '.lua'),
    'serve_stale < cache',
    'fallback_tcp'
}

-- Global policies
for _, item in ipairs(policy.special_names) do policy.add(item.cb) end

local function match_query_type(action, target_qtype)
    return function (state, query)
        if query.stype == target_qtype then return action else return nil end
    end
end

policy.add(match_query_type(policy.ANSWER({[kres.type.SOA] = {rdata = kres.parse_rdata({'SOA . . 1 1 1 1 ' .. max_ttl}), ttl = max_ttl}}, true), kres.type.HTTPS))
policy.add(match_query_type(policy.ANSWER({[kres.type.SOA] = {rdata = kres.parse_rdata({'SOA . . 1 1 1 1 ' .. max_ttl}), ttl = max_ttl}}, true), kres.type.SVCB))
policy.add(policy.all(policy.FLAGS({'NO_EDNS', 'NO_0X20'})))

-- Instance specific logic
if systemd_instance == '1' then
    policy.add(policy.rpz(policy.ANSWER({
        [kres.type.A]    = { rdata = kres.str2ip('0.0.0.0'), ttl = negative_ttl },
        [kres.type.AAAA] = { rdata = kres.str2ip('::'),      ttl = negative_ttl },
    }), '/etc/knot-resolver/deny.rpz', true))
    
    policy.add(policy.rpz(policy.STUB('127.0.0.2'), '/etc/knot-resolver/proxy.rpz', true))
    policy.add(policy.suffix(policy.FORWARD({'94.247.43.254', '95.216.99.249', '152.53.15.127', '185.226.181.19'}), alternative_zones))
    policy.add(policy.all(policy.FORWARD(current_upstreams.main)))
else
    policy.add(policy.rpz(policy.ANSWER({
        [kres.type.A]    = { rdata = kres.str2ip('0.0.0.0'), ttl = negative_ttl },
        [kres.type.AAAA] = { rdata = kres.str2ip('::'),      ttl = negative_ttl },
    }), '/etc/knot-resolver/deny2.rpz', true))
    
    policy.add(policy.suffix(policy.FORWARD({'94.247.43.254', '95.216.99.249', '152.53.15.127', '185.226.181.19'}), alternative_zones))
    policy.add(policy.all(policy.FORWARD(current_upstreams.proxy)))
end

trust_anchors.remove('.')
net.ipv6 = true
cache.min_ttl(min_ttl)
cache.max_ttl(max_ttl)
